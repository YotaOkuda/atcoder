'''
方針
- DP で解く
- dp[i] は総和が i であるような数列の個数を表す
- dp[i] は dp[0] ～ dp[i - 3] の総和となる（各項が 3 以上である必要があるため）
- ある数列で総和 i を作ると考えた場合、最後の項を x とすると
  x >= 3, それ以外の部分の総和は i - x
- 例えば、総和が 7 になる数列を考える場合
  - 最後の項が 3 の場合 → 残りの部分の総和は 7 - 3 = 4
  - 最後の項が 4 の場合 → 残りの部分の総和は 7 - 4 = 3
  - 最後の項が 7 の場合 → 残りの部分の総和は 7 - 7 = 0
  よって dp[i] = dp[i - 3] + dp[i - 4] + ... + dp[0]
'''
'''
S = int(input())

DIVISOR = 10 ** 9 + 7

# dp 用の配列
dp = [0] * (S + 1)
# 初期値
dp[0] = 1

# 1, 2, ..., S まで各 dp を求める
for i in range(1, S + 1):
    for j in range(0, i - 2):
        dp[i] += dp[j]
        dp[i] %= DIVISOR
        
print(dp[S])
'''

# 計算量 O(S^2)


# --- 累積和を用いて計算量を削減 ---

S = int(input())

DIVISOR = 10 ** 9 + 7

# dp 用の配列
dp = [0] * (S + 1)
dp[0] = 1

# 累積和用の配列（sdp[i] は総和が 0 から i までの dp の累積和）
sdp = [0] * (S + 1)
sdp[0] = 1

# 累積和を用いて dp を求める
for i in range(1, S + 1):
  if i >= 3:
    dp[i] = sdp[i - 3]
  
  sdp[i] = (sdp[i - 1] + dp[i]) % DIVISOR  # 累積和を更新
    
print(dp[S])

# 計算量 O(S)